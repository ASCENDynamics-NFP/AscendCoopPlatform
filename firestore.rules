rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /listings {
      allow list: if true;  // Allow listing collection queries, essential for features like filtering and pagination.
    }

    // Listings collection rules
    match /listings/{listingId} {
      allow read: if true; // Anyone can view listings
      allow create: if request.auth != null; // Must be logged in to create
      allow update, delete: if request.auth != null && 
        request.auth.uid == resource.data.createdBy; // Only creator can modify
    }

    // Allow authenticated users to apply for listings
    match /listings/{listingId}/relatedAccounts/{relatedAccountId} {
      allow create, read, write, delete: if request.auth.uid != null; // Only authenticated users
    }

    // Helper to check if user is the owner of the given account
    function isAccountOwner(accId) {
      return request.auth != null && request.auth.uid == accId;
    }

    // Helper to check if user is an admin of the given account (only for group accounts)
    function isAccountAdmin(accId) {
      return request.auth != null &&
        get(/databases/$(database)/documents/accounts/$(accId)).data.type == 'group' && (
          // Group owner short-circuit
          request.auth.uid == accId ||
          // Denormalized adminIds or moderatorIds
          (
            (
              get(/databases/$(database)/documents/accounts/$(accId)).data.adminIds != null &&
              request.auth.uid in get(/databases/$(database)/documents/accounts/$(accId)).data.adminIds
            ) ||
            (
              get(/databases/$(database)/documents/accounts/$(accId)).data.moderatorIds != null &&
              request.auth.uid in get(/databases/$(database)/documents/accounts/$(accId)).data.moderatorIds
            )
          )
        );
    }

    function isAcceptedFriend(accId) {
      return request.auth != null && 
        exists(/databases/$(database)/documents/accounts/$(accId)/relatedAccounts/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/accounts/$(accId)/relatedAccounts/$(request.auth.uid)).data.type == 'user' &&
        get(/databases/$(database)/documents/accounts/$(accId)/relatedAccounts/$(request.auth.uid)).data.status == 'accepted';
    }

    function isAcceptedGroup(accId) {
      return request.auth != null && 
        exists(/databases/$(database)/documents/accounts/$(accId)/relatedAccounts/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/accounts/$(accId)/relatedAccounts/$(request.auth.uid)).data.type == 'group' &&
        get(/databases/$(database)/documents/accounts/$(accId)/relatedAccounts/$(request.auth.uid)).data.status == 'accepted';
    }

    // Generic membership helper: any accepted relatedAccount regardless of type
    function isMember(accId) {
      return request.auth != null &&
        exists(/databases/$(database)/documents/accounts/$(accId)/relatedAccounts/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/accounts/$(accId)/relatedAccounts/$(request.auth.uid)).data.status == 'accepted';
    }

    // ===== Section-level privacy helpers =====
    function relationForViewer(accId) {
      return request.auth != null &&
        exists(/databases/$(database)/documents/accounts/$(accId)/relatedAccounts/$(request.auth.uid))
        ? get(/databases/$(database)/documents/accounts/$(accId)/relatedAccounts/$(request.auth.uid)).data
        : null;
    }

    function hasOverride(accId, section) {
      let r = relationForViewer(accId);
      return r != null && (
        (r.sectionOverrides != null && r.sectionOverrides[section] != null && r.sectionOverrides[section].allow == true) ||
        (r.canAccessContactInfo == true && section == 'contactInformation')
      );
    }

    function isPartner(accId) {
      let r = relationForViewer(accId);
      return r != null && r.status == 'accepted' && r.relationship == 'partner';
    }

    function isFriend(accId) {
      let r = relationForViewer(accId);
      return r != null && r.status == 'accepted' && r.relationship == 'friend';
    }

    function isGroupRelation(accId) {
      let r = relationForViewer(accId);
      return r != null && r.status == 'accepted' && r.type == 'group';
    }

    function sectionVisibility(accId, section) {
      let acc = get(/databases/$(database)/documents/accounts/$(accId)).data;
      return acc.privacySettings != null && acc.privacySettings[section] != null && acc.privacySettings[section].visibility != null
        ? acc.privacySettings[section].visibility
        : 'public';
    }

    function isAllowedByAudience(accId, section) {
      let v = sectionVisibility(accId, section);
      return (v == 'public') ||
        (v == 'authenticated' && request.auth != null) ||
        (v == 'related' && isMember(accId)) ||
        (v == 'groups' && isGroupRelation(accId)) ||
        (v == 'admins' && isAccountAdmin(accId)) ||
        (v == 'members' && isMember(accId)) ||
        (v == 'partners' && isPartner(accId)) ||
        (v == 'friends' && isFriend(accId));
    }

    // Account-level allow/block lists
    function inAllowlist(accId, section) {
      let acc = get(/databases/$(database)/documents/accounts/$(accId)).data;
      return request.auth != null && acc.privacySettings != null && acc.privacySettings[section] != null && acc.privacySettings[section].allowlist != null && request.auth.uid in acc.privacySettings[section].allowlist;
    }

    function inBlocklist(accId, section) {
      let acc = get(/databases/$(database)/documents/accounts/$(accId)).data;
      return request.auth != null && acc.privacySettings != null && acc.privacySettings[section] != null && acc.privacySettings[section].blocklist != null && request.auth.uid in acc.privacySettings[section].blocklist;
    }

    function canViewSection(accId, section) {
      return (
        // Owner/admins always allowed
        (isAccountOwner(accId) || isAccountAdmin(accId)) ||
        // Allowlist grants access regardless of audience
        inAllowlist(accId, section) ||
        // Blocklist denies access, otherwise audience or explicit override applies
        (!inBlocklist(accId, section) &&
          (isAllowedByAudience(accId, section) || hasOverride(accId, section)))
      );
    }

    // Project subcollections within accounts
    match /accounts/{accountId}/projects {
      // Allow listing projects to the owner or any accepted member
      allow list: if isAccountOwner(accountId) || isMember(accountId);
    }
    match /accounts/{accountId}/projects/{projectId} {
      // Allow reading a project to the owner or any accepted member
      allow read: if isAccountOwner(accountId) || isMember(accountId);
      // Only admins can create/update
      allow create, update: if isAccountAdmin(accountId);
      // Prevent delete when there are associated time entries by requiring counter == 0
      allow delete: if isAccountAdmin(accountId) &&
        (
          !resource.data.keys().hasAny(['timeEntryCount']) ||
          resource.data.timeEntryCount == 0
        );
    }

    match /accounts {
      allow list: if isPublicUser() || isPublicGroup();

      // Public Group access
      function isPublicGroup() {
        return (resource.data.privacy == 'public' && resource.data.type == 'group');
      }

      // Public User access
      function isPublicUser() {
        return (request.auth != null && resource.data.privacy == 'public' && resource.data.type == 'user');
      }
    }

    // Match the Account collection
    match /accounts/{accountId} {
      
      function isAccountOwner() {
        return request.auth != null && request.auth.uid == accountId;
      }

      function isGroupAdmin() {
        return request.auth != null &&
          get(/databases/$(database)/documents/accounts/$(accountId)).data.type == 'group' &&
          (
            // Group owner short-circuit
            request.auth.uid == accountId ||
            // Denormalized adminIds or moderatorIds
            (
              (get(/databases/$(database)/documents/accounts/$(accountId)).data.adminIds != null &&
               request.auth.uid in get(/databases/$(database)/documents/accounts/$(accountId)).data.adminIds) ||
              (get(/databases/$(database)/documents/accounts/$(accountId)).data.moderatorIds != null &&
               request.auth.uid in get(/databases/$(database)/documents/accounts/$(accountId)).data.moderatorIds)
            )
          );
      }

      // Friends-only access
      function isAcceptedFriend() {
        return request.auth != null && 
          exists(/databases/$(database)/documents/accounts/$(accountId)/relatedAccounts/$(request.auth.uid)) &&
          get(/databases/$(database)/documents/accounts/$(accountId)/relatedAccounts/$(request.auth.uid)).data.type == 'user' &&
          get(/databases/$(database)/documents/accounts/$(accountId)/relatedAccounts/$(request.auth.uid)).data.status == 'accepted';
      }

      // Groups-only access
      function isAcceptedGroup() {
        return request.auth != null && 
          exists(/databases/$(database)/documents/accounts/$(accountId)/relatedAccounts/$(request.auth.uid)) &&
          get(/databases/$(database)/documents/accounts/$(accountId)/relatedAccounts/$(request.auth.uid)).data.type == 'group' &&
          get(/databases/$(database)/documents/accounts/$(accountId)/relatedAccounts/$(request.auth.uid)).data.status == 'accepted';
      }

      // Public Group access
      function isPublicGroup() {
        return (resource.data.privacy == 'public' && resource.data.type == 'group');
      }

      // Public User access
      function isPublicUser() {
        return (request.auth != null && resource.data.privacy == 'public' && resource.data.type == 'user');
      }

      // Allow read if the user is accessing their own account
      allow read: if (isAccountOwner() || isAcceptedFriend() || isAcceptedGroup() || isPublicGroup() || isPublicUser());

      // General write rule allows owners or group admins/moderators
      // For account owners, allow all operations (create, update, delete)
      // For new accounts (type: 'new'), the owner can always update regardless of account type
      allow create: if isAccountOwner();
      allow update: if isAccountOwner() || isGroupAdmin();
      allow delete: if isAccountOwner();
    }

    // Gated sections under accounts
    match /accounts/{accountId}/sections {
      allow list: if false; // prevent listing sections collections
    }
    match /accounts/{accountId}/sections/contactInfo {
      allow read: if canViewSection(accountId, 'contactInformation');
      allow create, update: if isAccountOwner(accountId) || isAccountAdmin(accountId);
      allow delete: if isAccountOwner(accountId) || isAccountAdmin(accountId);
    }

    // Rules for relatedAccount
    // Do not allow blanket listing; rely on per-document read rules below
    match /accounts/{accountId}/relatedAccounts {
      // Allow listing for authenticated users; per-document read rules below
      // enforce section privacy (membersList/partnersList/friendsList) so only
      // allowed relationship docs are returned in query results.
      allow list: if request.auth != null;
    }
    match /accounts/{accountId}/relatedAccounts/{relatedAccountId} {
      function isAccountOwner() {
        return request.auth != null && request.auth.uid == accountId;
      }

      function isGroupAdmin() {
        return request.auth != null &&
          get(/databases/$(database)/documents/accounts/$(accountId)).data.type == 'group' &&
          (request.auth.uid == accountId || // Group owner has admin access
           (exists(/databases/$(database)/documents/accounts/$(accountId)/relatedAccounts/$(request.auth.uid)) &&
            get(/databases/$(database)/documents/accounts/$(accountId)/relatedAccounts/$(request.auth.uid)).data.status == 'accepted' &&
            (get(/databases/$(database)/documents/accounts/$(accountId)/relatedAccounts/$(request.auth.uid)).data.access == 'admin' ||
             get(/databases/$(database)/documents/accounts/$(accountId)/relatedAccounts/$(request.auth.uid)).data.access == 'moderator')));
      }

      function isRelatedToAccount() {
        return request.auth != null &&
          (request.auth.uid == accountId || request.auth.uid == relatedAccountId);
      }

      // Loosened: allow any authenticated user to read relatedAccounts docs.
      // App layer is responsible for filtering visibility per privacy settings.
      allow read: if request.auth != null;

      allow create, write, delete: if isAccountOwner() || isGroupAdmin() || isRelatedToAccount();
    }

    // Allow listing the relatedListings subcollection for authenticated users
    match /accounts/{accountId}/relatedListings {
      allow list: if request.auth.uid != null;
    }
    match /accounts/{accountId}/relatedListings/{listingId} {
      allow create, read, write, delete: if request.auth.uid != null;  // Only authenticated users
    }

    // Time entries within group accounts
    match /accounts/{accountId}/timeEntries/{entryId} {
      function isGroupAccount() {
        return get(/databases/$(database)/documents/accounts/$(accountId)).data.type == 'group';
      }

      function isGroupOwner() {
        return request.auth != null && request.auth.uid == accountId && isGroupAccount();
      }

      function isGroupMember() {
        return request.auth != null &&
          exists(/databases/$(database)/documents/accounts/$(accountId)/relatedAccounts/$(request.auth.uid)) &&
          get(/databases/$(database)/documents/accounts/$(accountId)/relatedAccounts/$(request.auth.uid)).data.status == 'accepted';
      }

      function isGroupMemberOrOwner() {
        return isGroupOwner() || isGroupMember();
      }

      function isGroupAdmin() {
        return request.auth != null &&
          isGroupAccount() &&
          (request.auth.uid == accountId || // Group owner has admin access
           (exists(/databases/$(database)/documents/accounts/$(accountId)/relatedAccounts/$(request.auth.uid)) &&
            get(/databases/$(database)/documents/accounts/$(accountId)/relatedAccounts/$(request.auth.uid)).data.access == 'admin'));
      }

      function hasValidProject() {
        // Require valid project that exists and is not archived
        return request.resource.data.projectId != null &&
               exists(/databases/$(database)/documents/accounts/$(accountId)/projects/$(request.resource.data.projectId)) &&
               get(/databases/$(database)/documents/accounts/$(accountId)/projects/$(request.resource.data.projectId)).data.archived == false;
      }

      function canCreateEntry() {
        return isGroupAccount() && isGroupMemberOrOwner() && hasValidProject();
      }

      function isValidStatus(status) {
        return status == 'pending' || status == 'draft' || status == 'approved' || status == 'rejected';
      }

      allow read: if isGroupAccount() && isGroupMemberOrOwner();
      
      // Members can create with pending/draft, admins can create with any valid status
      allow create: if canCreateEntry() && isValidStatus(request.resource.data.status) &&
        (
          request.resource.data.status == 'pending' || 
          request.resource.data.status == 'draft' ||
          (isGroupAdmin() && request.resource.data.status == 'approved')
        );
        
      // Updates: admins can update any, users can only update their own non-approved entries
      allow update: if canCreateEntry() && isValidStatus(request.resource.data.status) &&
        (
          isGroupAdmin() ||
          (
            request.auth.uid == resource.data.userId &&
            resource.data.status != 'approved' &&
            resource.data.status != 'rejected' &&
            request.resource.data.status != 'approved' &&
            request.resource.data.status != 'rejected'
          )
        );
      allow delete: if isGroupAccount() && isGroupMemberOrOwner() &&
        (
          isGroupAdmin() ||
          (
            request.auth.uid == resource.data.userId &&
            resource.data.status != 'approved'
          )
        );
    }
    
    // Rules for AppFeedback
    match /feedback/{accountId} {
      function isAccountOwner() {
        return request.auth.uid == accountId;
      }

      allow create: if isAccountOwner();
      allow read, write: if request.auth.uid != null; // Only logged in users can read and write feedback
      allow delete: if false;
    }

    // Rules for Chat/Messaging System
    match /chats/{chatId} {
      // Helper function to check if user is a participant in the chat
      function isParticipant() {
        return request.auth != null && 
               request.auth.uid in resource.data.participants;
      }

      // Helper function to check if user is a group admin for any participant accounts
      function isGroupAdminOfParticipants() {
        return request.auth != null &&
               exists(/databases/$(database)/documents/accounts/$(request.auth.uid)) &&
               get(/databases/$(database)/documents/accounts/$(request.auth.uid)).data.type == 'group';
      }

      // Helper function to check if user can access chat (participant or group admin)
      function canAccessChat() {
        return isParticipant() || isGroupAdminOfParticipants();
      }

      // Helper function to check if user can create this chat (all participants must be friends)
      function canCreateChat() {
        return request.auth != null &&
               request.auth.uid in request.resource.data.participants &&
               request.resource.data.participants.size() >= 2 &&
               request.resource.data.participants.size() <= 50; // Reasonable limit for group chats
      }

      // Helper function to check if user can modify participants
      function canModifyParticipants() {
        return request.auth != null && 
               resource.data.isGroup == true && // Only allow for group chats
               request.auth.uid in resource.data.participants && // User must be a participant
               (
                 // Allow adding participants (any participant can add others)
                 (request.resource.data.participants.size() > resource.data.participants.size() &&
                  request.resource.data.participants.size() <= 50) ||
                 // Allow removing participants (any participant can remove others, including themselves)
                 (request.resource.data.participants.size() < resource.data.participants.size() &&
                  request.resource.data.participants.size() >= 2) // Must keep at least 2 participants
               );
      }

      // Allow reading chats if user is a participant or group admin
      allow read: if canAccessChat();
      
      // Allow creating chats if user is included and participants are valid
      allow create: if canCreateChat();
      
      // Allow updating chat metadata or participants
      allow update: if canAccessChat() && 
                    (
                      // Allow metadata updates without changing participants
                      request.resource.data.participants == resource.data.participants ||
                      // Allow participant modifications for group chats
                      canModifyParticipants()
                    );
      
      // Only allow deleting if user has access (for leaving chats)
      allow delete: if canAccessChat();

      // Rules for messages subcollection
      match /messages/{messageId} {
        // Helper to check if user is participant of parent chat or group admin
        function isChatParticipant() {
          return request.auth != null && 
                 request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;
        }

        function isGroupAdminForChat() {
          return request.auth != null &&
                 exists(/databases/$(database)/documents/accounts/$(request.auth.uid)) &&
                 get(/databases/$(database)/documents/accounts/$(request.auth.uid)).data.type == 'group';
        }

        function canAccessMessages() {
          return isChatParticipant() || isGroupAdminForChat();
        }

        // Allow reading messages if user has access to the chat
        allow read: if canAccessMessages();
        
        // Allow creating messages if user is the sender and has chat access
        allow create: if request.auth != null && 
                      request.auth.uid == request.resource.data.senderId &&
                      canAccessMessages();
        
        // Allow updating own messages (for edit functionality, if implemented)
        allow update: if request.auth != null && 
                      request.auth.uid == resource.data.senderId &&
                      request.auth.uid == request.resource.data.senderId &&
                      canAccessMessages();
        
        // Allow deleting own messages
        allow delete: if request.auth != null && 
                      request.auth.uid == resource.data.senderId &&
                      canAccessMessages();
      }
    }

    // User encryption keys collection
    match /userKeys/{userId} {
      // Users can only read and write their own encryption keys
      allow read, write: if request.auth != null && request.auth.uid == userId;
      
      // Allow other users to read public keys for encryption purposes
      allow read: if request.auth != null;
    }

    // Notifications collection rules
    match /notifications/{notificationId} {
      // Allow authenticated users to create notifications if they are the sender
      allow create: if request.auth != null && 
                    request.auth.uid == request.resource.data.fromUserId;
      
      // Allow users to read their own notifications (recipient) or notifications they sent
      allow read: if request.auth != null && 
                  (request.auth.uid == resource.data.userId ||
                   request.auth.uid == resource.data.fromUserId);
      
      // Allow users to update their own notifications (recipient) or notifications they sent
      allow update: if request.auth != null && 
                    (request.auth.uid == resource.data.userId ||
                     request.auth.uid == resource.data.fromUserId);
      
      // Allow users to delete their own notifications (recipient) or notifications they sent
      allow delete: if request.auth != null && 
                    (request.auth.uid == resource.data.userId ||
                     request.auth.uid == resource.data.fromUserId);
    }
  }
}
